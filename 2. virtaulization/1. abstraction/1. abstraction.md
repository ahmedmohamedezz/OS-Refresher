# The Abstraction

## The Process

- **_process_**: running program

- question: how to provid the illusion that we have many CPUs. despite we only have a few ones ? 
  - by virtaulizing the CPU: running 1 process, then stopping it and running another, and so forth `time sharing the cpu`

- the cost of sharing the CPU is performance

- the ability of running several programs on the cpu is done via `context switching: time sharing mechanism`

- at any instant in time, we can summarize a process by taking an
inventory of the different pieces of the system it accesses or affects during the course of its execution

- **_machine state_**: what a program can read/update when it's running (memory, registers, persistent storage (IO))

- **_address space_**: space that a process can address

- special registers that form part of the machine state
  - Program Counter `PC` (aka Instruction Pointer `IP`): tells what is the currently executing instruction
  - `stack pointer` & `frame pointer`: manage the stack for function parameters, local variables, and return addresses

---

## Process API

- let's review some of the process APIs that any os have

- create: call to run a new program
- destroy: cause a process to exit, and maybe other to halt process execution
- wait: wait for a process to stop running
- suspend & resume a process
- status: collect/get information about a process

---

## Process Creation

- one mystery that we should unmask a bit is how programs are transformed into processes

### in order to run a program

- the os loads the program code & static data (init. vars) into memory (into the address space of a process)

- early/simple os load the whole program at once (eagerly). while modern ones loads them lazily (loading code as needed)

- to understand **_lazy loading_**, you will have to come through **_paging_** and **_swapping_**

- the os needs to do other things after loading the program code & data and before running the process like _allocating memory to the program runtime-stack_ (aka `stack`)

- C programs use the stack for local vars, function params, return addresses.

- the os initializes the stack with args (args of main() function)

- it also creates initial memory for the program's heap

- C programs uses heap for dynamically requested memory `malloc()`, `free()`

- heap is used for storing data-structures linked lists, hash tables, ...

- the os also do some extra work related to IO (to allow programs to read input & produce output)

- finally start running the program's `main()` entry-point, and transfer CPU control to the process.

---

## Process States

- a process can be in 1 of the following states at any given time
  
- `running`: currently executing instructions on a processor
- `ready`: ready to be assigned to a processor. but hasn't started
- `blocked`: the process performed an operation that makes it not ready to run until some event happens (initiated an I/O request to disk)

---

## Data Structures

- the os is a program. and like any program it has data-structures to keep track of relevant data

- examples:
  -  a list for all ready processes
  -  which process is running
  -  blocked processes
  
- the os system also keeps track of the last registers state before stopping the process. so, it can resume again from where it's stopped
